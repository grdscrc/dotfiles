function mkcd {
  mkdir "$@" && cd "$@";
}

function swop {
  if [ $# -ne 2 ]; then # Less than 2 parameters
    >&2 echo "Usage : swop <regex to replace> <replacement>" && return 0
  fi

  ack -l "$1" | xargs perl -pi -E "s/$1/$2/g";
}

function hush {
  $@ 2> /dev/null
}

function errcho {
  (>&2 echo $@)
}

function git_cherry_nibble {
  if [ $# -ne 1 ]; then # Other than 1 parameter
    >&2 echo "Usage : git_cherry_nibble <commit hash>"
    return 0
  fi

  git cherry-pick $1 && git reset --soft HEAD
}

function git_pop_branch {
  branchtopop=$(git current-branch)
  git checkout master
  git branch --delete $branchtopop
}

function deploy_sisra_proxy {
  echo $@
  DIR=`pwd`
  cd /Users/igor/work/syadem/sisra-ws-security-proxy
  gradle build
  ./deploy.sh $@
  cd $DIR
}

function log_sisra_proxy {
  if [[ $1 == "local" ]]; then
    tail -f /Users/igor/work/syadem/sisra-ws-security-proxy/log/development.log
  else
    hm ssh $1 prv "tail -f /opt/sisra_ws_security_proxy/sisra_ws_security_proxy.log"
  fi
}

function nokogiripleasewithversion {
  version="$1"
  libxml2_prefix=$(brew --prefix libxml2)
  gem install nokogiri -v "$version" -- \
    --use-system-libraries \
    --with-xml2-include="$libxml2_prefix"/include/libxml2
}

function colp {
  column_ref=$1
  awk "{print \$$column_ref}"
}

function line {
  lineno="$1"
  awk "FNR==$lineno"
}

function lines {
  start="$1"
  endd="$2"
  awk "FNR>=$start && FNR<=$endd"
}

function gchain {
  for command in "$@"; do
    echo $command | xargs git
  done
}

function rjq {
  if [[ $# < 1 ]]; then
    >&2 echo 'rjson $remote:$path $json_selector'
    return 0
  fi
  rclone lsjson $1 | jq $2
}

function agv {
  ag -l $@ | xargs -o vim +/\\c"$1"
}

function change_case {
  snake_head_regex='s/^([A-Z])/\L\1/g'
  snake_inner_regex='s/([a-z0-9])([A-Z])/\1_\L\2/g'

  camel_head_regex='s/^([a-z])/\L\1/g'
  camel_inner_regex='s/([a-z0-9]_?)([A-Z])/\1\U\2/g'

  kebab_head_regex='s/^([A-Z])/\L\1/g'

  if [[ $1 == "--snake" ]]; then
    head_regex=$snake_head_regex
    inner_regex=$snake_inner_regex
  elif [[ $1 == "--camel" ]]; then
    head_regex=$camel_head_regex
    inner_regex=$camel_inner_regex
  elif [[ $1 == "--kebab" ]]; then
    head_regex=$kebab_head_regex
    inner_regex=$camel_inner_regex
  else
    errcho "Invalid option $1"
    errcho "Available options : --snake, --camel, --kebab"
    return 0
  fi

  echo $2 | \
    gsed -E $inner_regex | \
    gsed -E $head_regex
}

function docker_bash {
  container="$1"

  docker exec -i $container bash -i
}

function between {
  mark1=$1
  mark2=$2
  awk "/$mark1/{flag=1;next}/$mark2/{flag=0}flag"
}

function brew_tally {
  brew outdated | \
    grep -v "$(brew list --pinned)" | \
    tee ~/.brew_outdated_packages | \
    wc -l| \
    xargs echo 'Brew outdated packages:'
}

function brew_upgrade {
  brew upgrade < ~/.brew_outdated_packages
}

function brew_check_updates {
  if [[ -e ~/.brew_outdated_packages ]]; then
    (( since_last_check = $(date +%s) - $(date -r ~/.brew_outdated_packages +%s) ))
    (( seconds_in_a_day = 24 * 60 * 60 ))

    if (( $since_last_check > $seconds_in_a_day )); then
      echo Outdated ~/.brew_outdated_packages
      brew_tally
    fi
  else
    echo Did not find ~/.brew_outdated_packages
    brew_tally
  fi
}

function p12ToCerAndKey {
  p12=$1
  cer=${p12%.p12}.cer
  key=${p12%.p12}.key

  openssl pkcs12 -in $p12 -out $cer -clcerts -nokeys
  openssl pkcs12 -in $p12 -out $key -nocerts -nodes
}
